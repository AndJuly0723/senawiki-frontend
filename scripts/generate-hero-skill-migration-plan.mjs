import { randomUUID } from 'node:crypto'
import { promises as fs } from 'node:fs'
import path from 'node:path'

const args = process.argv.slice(2)

const getArg = (name, fallback) => {
  const prefix = `--${name}=`
  const found = args.find((arg) => arg.startsWith(prefix))
  return found ? found.slice(prefix.length) : fallback
}

const bucket = getArg('bucket', 'senawiki-assets')
const skillsDir = getArg('skillsDir', 'public/images/heroskill')
const outDir = getArg('outDir', 'scripts/output/hero-skill-migration')
const heroesTable = getArg('heroesTable', 'heroes')
const idColumn = getArg('idColumn', 'id')
const prefix = getArg('prefix', 'hero-skills')

const extToMime = {
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.webp': 'image/webp',
  '.gif': 'image/gif',
}

const skillFileToColumn = {
  basic: 'basic_skill_image',
  skill1: 'skill1_image',
  skill2: 'skill2_image',
  passive: 'passive_skill_image',
}

const sqlEscape = (value) => String(value).replace(/'/g, "''")
const toPosix = (value) => value.split(path.sep).join('/')

const buildRows = async () => {
  const heroDirs = await fs.readdir(skillsDir, { withFileTypes: true })
  const rows = []
  const byHero = new Map()

  for (const dirEntry of heroDirs) {
    if (!dirEntry.isDirectory()) continue
    const heroId = dirEntry.name
    const absoluteDir = path.join(skillsDir, heroId)
    const files = await fs.readdir(absoluteDir, { withFileTypes: true })

    const heroColumns = {
      basic_skill_image: null,
      skill1_image: null,
      skill2_image: null,
      passive_skill_image: null,
    }

    for (const fileEntry of files) {
      if (!fileEntry.isFile()) continue
      const ext = path.extname(fileEntry.name).toLowerCase()
      const mimeType = extToMime[ext]
      if (!mimeType) continue

      const baseName = path.basename(fileEntry.name, ext).toLowerCase()
      const column = skillFileToColumn[baseName]
      if (!column) continue

      const key = `${prefix}/${randomUUID()}${ext}`
      const localPath = toPosix(path.join(absoluteDir, fileEntry.name))

      rows.push({
        heroId,
        column,
        localPath,
        key,
        mimeType,
      })

      heroColumns[column] = key
    }

    byHero.set(heroId, heroColumns)
  }

  return { rows, byHero }
}

const writeOutputs = async ({ rows, byHero }) => {
  await fs.mkdir(outDir, { recursive: true })

  const manifest = {
    generatedAt: new Date().toISOString(),
    bucket,
    prefix,
    fileCount: rows.length,
    heroCount: byHero.size,
    rows,
  }

  const uploadCommands = rows.map(
    (row) =>
      `aws s3 cp "${row.localPath}" "s3://${bucket}/${row.key}" --content-type "${row.mimeType}"`,
  )

  const sqlLines = []
  for (const [heroId, columns] of byHero.entries()) {
    const sets = Object.entries(columns).map(([column, key]) =>
      key ? `${column}='${sqlEscape(key)}'` : `${column}=NULL`,
    )
    sqlLines.push(
      `UPDATE ${heroesTable} SET ${sets.join(', ')} WHERE ${idColumn}='${sqlEscape(heroId)}';`,
    )
  }

  const sqlBody = [
    '-- generated by scripts/generate-hero-skill-migration-plan.mjs',
    'BEGIN;',
    ...sqlLines,
    'COMMIT;',
    '',
  ].join('\n')

  await Promise.all([
    fs.writeFile(path.join(outDir, 'manifest.json'), `${JSON.stringify(manifest, null, 2)}\n`, 'utf8'),
    fs.writeFile(path.join(outDir, 'upload.ps1'), `${uploadCommands.join('\n')}\n`, 'utf8'),
    fs.writeFile(
      path.join(outDir, 'upload.sh'),
      `#!/usr/bin/env bash\nset -euo pipefail\n\n${uploadCommands.join('\n')}\n`,
      'utf8',
    ),
    fs.writeFile(path.join(outDir, 'update-hero-skill-image-key.sql'), sqlBody, 'utf8'),
  ])
}

const main = async () => {
  const result = await buildRows()
  await writeOutputs(result)
  console.log(`Generated hero skill migration plan: ${result.rows.length} files`)
  console.log(`Output directory: ${outDir}`)
}

main().catch((error) => {
  console.error(error)
  process.exit(1)
})
