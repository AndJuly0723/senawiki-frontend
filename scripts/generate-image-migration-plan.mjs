import { randomUUID } from 'node:crypto'
import { promises as fs } from 'node:fs'
import path from 'node:path'

const args = process.argv.slice(2)

const getArg = (name, fallback) => {
  const prefix = `--${name}=`
  const found = args.find((arg) => arg.startsWith(prefix))
  if (!found) return fallback
  return found.slice(prefix.length)
}

const bucket = getArg('bucket', 'senawiki-assets')
const heroesDir = getArg('heroesDir', 'public/images/heroes')
const petsDir = getArg('petsDir', 'public/images/pets')
const outDir = getArg('outDir', 'scripts/output/image-migration')
const heroesTable = getArg('heroesTable', 'heroes')
const petsTable = getArg('petsTable', 'pets')
const idColumn = getArg('idColumn', 'id')

const extToMime = {
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.webp': 'image/webp',
  '.gif': 'image/gif',
}

const sqlEscape = (value) => String(value).replace(/'/g, "''")

const toPosix = (value) => value.split(path.sep).join('/')

const listImages = async (dirPath) => {
  const entries = await fs.readdir(dirPath, { withFileTypes: true })
  return entries
    .filter((entry) => entry.isFile())
    .map((entry) => entry.name)
    .filter((name) => extToMime[path.extname(name).toLowerCase()])
}

const buildPlanRows = async () => {
  const heroFiles = await listImages(heroesDir)
  const petFiles = await listImages(petsDir)

  const heroRows = heroFiles.map((fileName) => {
    const ext = path.extname(fileName).toLowerCase()
    const id = path.basename(fileName, ext)
    const key = `heroes/${randomUUID()}${ext}`
    const localPath = toPosix(path.join(heroesDir, fileName))
    return {
      entityType: 'HERO',
      entityId: id,
      localPath,
      key,
      mimeType: extToMime[ext],
    }
  })

  const petRows = petFiles.map((fileName) => {
    const ext = path.extname(fileName).toLowerCase()
    const id = path.basename(fileName, ext)
    const key = `pets/${randomUUID()}${ext}`
    const localPath = toPosix(path.join(petsDir, fileName))
    return {
      entityType: 'PET',
      entityId: id,
      localPath,
      key,
      mimeType: extToMime[ext],
    }
  })

  return [...heroRows, ...petRows]
}

const writeOutputs = async (rows) => {
  await fs.mkdir(outDir, { recursive: true })

  const manifest = {
    generatedAt: new Date().toISOString(),
    bucket,
    counts: {
      heroes: rows.filter((row) => row.entityType === 'HERO').length,
      pets: rows.filter((row) => row.entityType === 'PET').length,
      total: rows.length,
    },
    rows,
  }

  const psLines = rows.map(
    (row) =>
      `aws s3 cp "${row.localPath}" "s3://${bucket}/${row.key}" --content-type "${row.mimeType}"`,
  )
  const shLines = rows.map(
    (row) =>
      `aws s3 cp "${row.localPath}" "s3://${bucket}/${row.key}" --content-type "${row.mimeType}"`,
  )

  const sqlHeroLines = rows
    .filter((row) => row.entityType === 'HERO')
    .map(
      (row) =>
        `UPDATE ${heroesTable} SET image_key='${sqlEscape(row.key)}' WHERE ${idColumn}='${sqlEscape(row.entityId)}';`,
    )
  const sqlPetLines = rows
    .filter((row) => row.entityType === 'PET')
    .map(
      (row) =>
        `UPDATE ${petsTable} SET image_key='${sqlEscape(row.key)}' WHERE ${idColumn}='${sqlEscape(row.entityId)}';`,
    )

  const sqlBody = [
    '-- generated by scripts/generate-image-migration-plan.mjs',
    'BEGIN;',
    ...sqlHeroLines,
    ...sqlPetLines,
    'COMMIT;',
    '',
  ].join('\n')

  await Promise.all([
    fs.writeFile(path.join(outDir, 'manifest.json'), `${JSON.stringify(manifest, null, 2)}\n`, 'utf8'),
    fs.writeFile(path.join(outDir, 'upload.ps1'), `${psLines.join('\n')}\n`, 'utf8'),
    fs.writeFile(path.join(outDir, 'upload.sh'), `#!/usr/bin/env bash\nset -euo pipefail\n\n${shLines.join('\n')}\n`, 'utf8'),
    fs.writeFile(path.join(outDir, 'update-image-key.sql'), sqlBody, 'utf8'),
  ])
}

const main = async () => {
  const rows = await buildPlanRows()
  await writeOutputs(rows)
  console.log(`Generated migration plan: ${rows.length} files`)
  console.log(`Output directory: ${outDir}`)
}

main().catch((error) => {
  console.error(error)
  process.exit(1)
})
